####一、通过protobuf的定义文件.proto生成纯二进制流(而不是像protobuf一样会进行压缩处理)读写协议的ts代码，实现除了gate以外的服务都把协议通过这个流发送到gate,由gate来编码成压缩的protoco buffer发送到前端,减轻后端其他服务的负担(尤其的单实例服务)。
目前已经完成了对proto协议文件的读取整理与分析,还差生成ts代码部分。
难点:服务将二进制流发送到网关后，网关通过流中tag直接调用protobuf生成的js代码去写流压缩流,而不用在网关反序列化后再使用protobuf encode。

####二、重构RPC框架,里面太多重复的代码、将rpc连接层从WebSocket改成TCP


####三、客户端每一个按钮都可能在短时间内多次点击,即有可能在短时间内同一协议内容多次发送到服务端,引发bug
如同意好友请求时快速点击。需要在客户端做限制或者在服务端增加中间层预防。

####四、对relation进行压力测试，因为relation是单开的服务，尝试编写一个脚本加到很多好友然后频繁上下线测试relation瓶颈。
        或是考虑是否可以将relation服务去除,因为逛聊天的话用hall是完全足够的，考虑如何处理上下线通知。

~~####五、hall不出现有状态服务~~

####六、考虑是否使用webpack打包项目,这样经过打包发布的项目可以不需要在服务器上安装依赖(npm install)
会导致一些自动注册的逻辑出现问题,如card注册,handler auto mapping,因为这些注册逻辑都是寻找指定目录的文件进行自动注册的，
而使用webpack就没有相应路径了。

####七、游戏逻辑中有大量消息同时广播
每一个事件都是单独的一个protobuf message
比如回合开始时触发卡牌开始事件、抽卡、疲劳都是对应的消息
一条条发送给玩家

这样就会造成要发很多websocket包。(后续服务内部RPC连接层改成TCP，减少包体大小)
game到网关、网关到玩家。
websocket包体也是有消耗的。
解决方案是做message合并发送，客户端解析处理。
未来的消息结构：
连续消息:
```
|1字节===>是|包体长度:4字节|cmd|scmd|message|.......|包体长度:4字节|cmd|scmd|message|
```
非连续消息:
```
|1字节===>否|cmd|scmd|message|
```